### 第3次实践作业（2025.09.08）

 - 个人电脑D盘或E盘，新建VM文件夹 
 - 在VM文件夹中新建Hadoop文件夹和Stream9GUI文件夹 
 - 参考课本11页~31页，创建虚拟机Hadoop1（Minimal Install）
 - 创建虚拟机Stream9GUI（Server with GUI） 
 - 掌握vi、sed、uuidgen、nmcli、ip、ping等命令的使用 



### 1.修改主机名

由于Hadoop2和Hadoop3是由Hadoop1 克隆来的，因此他们的主机名一致  必须进行修改，方便区分

==命令(以Hadoop2为例)==

`hostnamectl set-hostname hadoop2`

> #### 1. `hostnamectl`：主机名管理工具
>
> `hostnamectl` 是一个命令行工具，属于 `systemd` 工具集的一部分。它专门用于查询和更改系统的主机名以及相关的设置。与传统的 `hostname` 命令相比，`hostnamectl` 提供了更强大和一致的管理方式。
>
> #### 2. `set-hostname`：执行的操作
>
> 这是 `hostnamectl` 命令的一个子命令，告诉 `hostnamectl` 你想要执行的动作是“设置主机名”。
>
> #### 3. `hadoop2`：新的主机名
>
> 这是你为你的机器指定的新名字。执行命令后，系统的新静态主机名就会变成 `hadoop`。





#### 1.1  ctl后缀详细解释

`ctl` 后缀是 **"control"** 的缩写，意为“**控制**”或“**管理**”。

所以，一个以 `ctl` 结尾的命令，通常意味着它是一个**控制工具 (control tool)**，用于管理和配置某个特定的系统服务或子系统。



这种命名方式让命令的用途变得非常清晰和可预测。当你看到一个以 `ctl` 结尾的命令时，你基本可以猜到：

1. **它的功能**：它是一个管理工具，用来查询状态、启动、停止、启用、禁用或配置某项功能。
2. **它管理的对象**：命令 `ctl` 前面的部分，就是它所管理的对象。

> eg:
>
> **`systemctl`**: **System** **Control**
>
> - 这是最核心的控制命令，用于管理 `systemd` 系统和服务管理器。你可以用它来启动、停止、重启服务（如 `httpd`, `sshd`），设置开机自启等。它是 `service` 和 `chkconfig` 等旧命令的替代品。
>
> **`hostnamectl`**: **Hostname** **Control**
>
> - 它专门用于**控制**和管理系统的**主机名**。



### 2.修改映射文件

------

![Snipaste_2025-09-19_20-48-10](E:\Typoar1_9_4\Hadoop_study\image\Snipaste_2025-09-19_20-48-10.png)

==检查 `/etc/hosts` 文件内容是否正确==

```
cat /etc/hosts
```





#### 2.1详细操作步骤

为`Hadoop1`, `Hadoop2`, `Hadoop3` 这三台虚拟机配置固定的静态IP地址，防止因重启导致IP地址变化，确保集群网络稳定。配置信息如下：

- **网关 (Gateway)**: `192.168.121.2` (所有虚拟机都一样)
- **DNS服务器**: `114.114.114.114` (所有虚拟机都一样)
- **IP 地址**:
  - Hadoop1: `192.168.121.160`
  - Hadoop2: `192.168.121.161`
  - Hadoop3: `192.168.121.162`



好的，已经根据您提供的后续三张图片内容，为您整理出了给虚拟机配置静态IP地址的详细操作步骤。

书上的操作是**以`Hadoop2`这台虚拟机为例**进行讲解的，您需要为三台虚拟机（Hadoop1, Hadoop2, Hadoop3）都执行类似的操作，**关键区别在于各自的IP地址不同**。

以下是详细的操作步骤：



##### 目标

为`Hadoop1`, `Hadoop2`, `Hadoop3` 这三台虚拟机配置固定的静态IP地址，防止因重启导致IP地址变化，确保集群网络稳定。配置信息如下：

- **网关 (Gateway)**: `192.168.121.2` (所有虚拟机都一样)
- **DNS服务器**: `114.114.114.114` (所有虚拟机都一样)
- **IP 地址**:
  - Hadoop1: `192.168.121.160`
  - Hadoop2: `192.168.121.161`
  - Hadoop3: `192.168.121.162`

------



##### 操作步骤 (以配置 Hadoop2 为例)

##### 第1步：编辑网络配置文件



1. 在 `Hadoop2` 的终端中，使用 `vi` 编辑器打开网络连接配置文件。书中的网卡名为 `ens33`，您的可能也一样。

   ==Bash==

   ```
   # 使用 sudo 获取管理员权限
   sudo vi /etc/NetworkManager/system-connections/ens33.mconnection
   ```

   *注意：如果你的文件名不是 `ens33.mconnection`，可以通过 `ls /etc/NetworkManager/system-connections/` 命令查看正确的文件名。*

2. 找到 `[ipv4]` 这个配置段，将其修改为如下内容。您需要修改 `method`，并添加 `dns` 和 `address1` 这两行。

   ```
   [ipv4]
   # 将 method 从 auto 修改为 manual
   method=manual
   
   # 添加下面两行，指定 DNS、IP地址/子网掩码、网关
   dns=114.114.114.114;
   address1=192.168.121.161/24,192.168.121.2
   
   # 其他内容保持不变
   # ...
   ```

   **参数解释**:

   - `method=manual`: 表示使用手动（静态）方式配置IP。
   - `dns=...`: 设置DNS服务器地址。
   - `address1=...`: 设置IP地址、子网掩码和网关。
     - `192.168.121.161` 是 `Hadoop2` 的静态IP。
     - `/24` 是子网掩码，相当于 `255.255.255.0`。
     - `,` 逗号后面的 `192.168.121.2` 是网关地址。

3. 修改完成后，保存并退出 `vi` 编辑器 (按 `ESC`，然后输入 `:wq` 并回车)。



##### 第2步：修改 UUID (仅当虚拟机是克隆的时需要)



如果你的 `Hadoop2` 和 `Hadoop3` 是从 `Hadoop1` 克隆而来的，它们的网络配置UUID会完全相同，这会导致冲突。你需要为每台克隆的机器生成一个新的唯一UUID。

在 `Hadoop2` 终端中执行以下命令，它会自动替换掉旧的UUID：

```
sudo sed -i 's/uuid=.*/uuid='$(uuidgen)'/' /etc/NetworkManager/system-connections/ens33.mconnection
```

*这个命令会找到以 `uuid=` 开头的行，并将其替换为一个新生成的唯一ID。*



##### 第3步：应用网络配置并验证



1. 重新加载网络配置，使修改生效。

   ```
   sudo nmcli c reload
   ```

2. 重启网络连接。

   ```
   sudo nmcli c up ens33
   ```

   *如果提示 `ens33` 已经是激活状态，可以先 `down` 再 `up`: `sudo nmcli c down ens33 && sudo nmcli c up ens33`*

3. 检查IP地址是否配置成功。

   ```
   ip addr show ens33
   ```

   在返回的信息中，你应该能看到 `inet` 字段显示为你刚刚配置的IP地址 `192.168.121.161/24`。

------



##### 第4步：为 Hadoop1 和 Hadoop3 重复以上操作

现在，您需要登录到 `Hadoop1` 和 `Hadoop3` 这两台虚拟机，重复执行 **第1步到第3步** 的所有操作。

**唯一需要注意的区别是**：在 **第1步** 编辑配置文件时，`address1` 的值必须使用它们各自对应的IP地址：

- **在 `Hadoop1` 上**, `address1` 应该设置为:

  ```
  address1=192.168.121.160/24,192.168.121.2
  ```

- **在 `Hadoop3` 上**, `address1` 应该设置为:

  ```
  address1=192.168.121.162/24,192.168.121.2
  ```

  *别忘了，如果 `Hadoop3` 也是克隆的，**一定要在 `Hadoop3` 上也执行第2步的 `sed` 命令来更新UUID**。*

全部配置完成后，您三台虚拟机的静态IP就设置好了。



##### 最终验证 (强烈建议)

IP地址正确是第一步，也是最关键的一步。为了确保万无一失，我们还需要做一个最终的连通性测试，**确保它们之间不仅IP通，而且主机名也能互相识别**。

请您登录到**任意一台**虚拟机上（例如，登录到 `hadoop1`），然后执行下面的 `ping` 命令：

```
# 在 hadoop1 上测试到 hadoop2 的连通性
ping -c 3 hadoop2

# 在 hadoop1 上测试到 hadoop3 的连通性
ping -c 3 hadoop3
```

**如果您看到类似下面的返回信息，并且丢包率（packet loss）为 `0%`，那就代表您的整个网络基础环境已经完美配置好了！**

```
PING hadoop2 (192.168.121.161) 56(84) bytes of data.
64 bytes from hadoop2 (192.168.121.161): icmp_seq=1 ttl=64 time=0.512 ms
64 bytes from hadoop2 (192.168.121.161): icmp_seq=2 ttl=64 time=0.487 ms
64 bytes from hadoop2 (192.168.121.161): icmp_seq=3 ttl=64 time=0.531 ms

--- hadoop2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2049ms
```





==建议再次检查，`Hadoop1` `Hadoop2` `Hadoop3`上的 `/etc/hosts` 文件内容是否完整==









### 3. 补充资料

#### 3.1uuid的使用

```
sudo sed -i 's/uuid=.*/uuid='$(uuidgen)'/' /etc/NetworkManager/system-connections/ens33.mconnection
```

**整体概览**   这条命令的作用是：**用一个全新的、随机生成的UUID，去替换掉网络配置文件中旧的UUID行。** 这在克隆虚拟机后，为了避免网络配置冲突时非常有用。

------

> ### 语法逐段详解
>
> #### 2. `sed -i '...'`
>
> - **`sed`**: 这是命令的核心，`sed` 是 **S**tream **ED**itor（流编辑器）的缩写。它是一个强大的文本处理工具，可以对文本文件进行查找、替换、插入、删除等操作，而无需手动打开文件。
> - **`-i`**: 这是 `sed` 的一个选项，意思是 **i**n-place（原地编辑）。
>   - 如果没有 `-i`，`sed` 只会把修改后的结果打印在屏幕上，而原始文件**不会被改变**。
>   - 加上 `-i` 后，`sed` 会**直接修改原始文件**，这正是我们想要的效果。
>
> ------
>
> 
>
> #### 3. `'s/uuid=.*/uuid='$(uuidgen)'/'` (核心替换脚本)
>
> 这部分是 `sed` 的“剧本”，告诉 `sed` 要做什么。它遵循 `s/查找内容/替换内容/` 的基本格式。
>
> - **`s`**: 代表 **s**ubstitute（替换）命令。
> - **`/`**: 分隔符，用来隔开“查找内容”和“替换内容”。
>
> ##### **查找内容: `uuid=.\*`**
>
> 这是一个正则表达式，用来匹配要被替换掉的文本。
>
> - `uuid=`: 匹配文本中一模一样的 `uuid=` 这几个字符。
> - `.*`: 这是一个通配符。
>   - `.` (点) 代表**任意单个字符**。
>   - `*` (星号) 代表它前面的字符可以出现**零次或多次**。
>   - 所以 `.*` 组合起来就代表 “**任意长度的任意字符**”。
> - **`uuid=.\*` 整体含义**: 匹配以 `uuid=` 开头，并包含其后直到行尾的所有内容。
>
> 
>
> ##### **替换内容: `uuid='$(uuidgen)'`**
>
> 这是用来替换上面找到内容的新文本。
>
> - `uuid=`: 这是新内容的前缀，我们希望替换后的行依然以 `uuid=` 开头。
> - **`$(uuidgen)`**: 这是整条命令的**点睛之笔**，它叫做 **命令替换 (Command Substitution)**。
>   - 在shell（命令行解释器）执行`sed`命令**之前**，它会先扫描整行命令。
>   - 当它看到 `$(...)` 这个结构时，它会**立即执行**括号里的命令，也就是 `uuidgen`。
>   - ==`uuidgen` 是一个专门用来生成新的、唯一的UUID的小程序。它会输出一串像 `f47ac10b-58cc-4372-a567-0e02b2c3d479` 这样的字符串。==
>   - 然后，shell会把 `uuidgen` 的输出结果**无缝地粘贴**回原来的位置。
>   - 所以，在`sed`看来，它收到的命令实际上是类似于 `s/uuid=.*/uuid=f47ac10b-58cc-4372-a567-0e02b2c3d479/` 这样的。
>
> ------
>
> 
>
> #### 4. `/etc/NetworkManager/system-connections/ens33.mconnection`
>
> - **含义**: 这是 `sed` 命令要操作的目标文件，也就是那个需要修改的网络配置文件。
>
> ------
>
> 
>
> ### 执行流程总结
>
> 1. 您按下回车键。
> 2. `sudo` 请求管理员权限。
> 3. Shell（命令行）看到 `$(uuidgen)`，于是**暂停**执行`sed`，转而先运行 `uuidgen`。
> 4. `uuidgen` 程序生成一个新的UUID（例如 `a1b2c3d4-...`）并输出。
> 5. Shell将这个输出结果“拼接”回原命令，形成一条完整的`sed`命令，类似于 `sed -i 's/uuid=.*/uuid=a1b2c3d4-.../'`。
> 6. `sed` 开始执行，它打开目标文件，找到以 `uuid=` 开头的那一行，并将整行替换为 `uuid=a1b2c3d4-...`。
> 7. 因为有 `-i` 选项，修改被直接保存到文件中。





#### 3.2 nmcli 命令详解

`nmcli [要管理的对象] [要执行的动作] [具体的目标]`

`nmcli c reload`命令是将磁盘状态（您保存的更改）与服务的内存状态同步的关键步骤。

  `nmcli` (固定开头)这部分很简单，就是把你“网络管家”的名字喊出来，让他知道你要下指令了。**所有命令都以 `nmcli` 开头**。

> #### `nmcli`
>
> - **代表**：**网络***管理器**命令行**界面。
> - **角色**：这是主命令。它是您在终端中用来与 NetworkManager 服务交互的主要工具，NetworkManager 服务是大多数现代 Linux 系统（CentOS、RHEL、Ubuntu、Fedora 等）上的标准网络守护进程。
>
> #### `c`
>
> - *代表**：`connection`。
> - **角色**：这是您想要管理的“对象”。`nmcli`可以管理不同的对象，如`device`（物理接口）、`general`（整体状态）等。通过指定`c`或`connection`，您是在告诉`nmcli`“我想做一些与我保存的网络配置文件相关的事情”。
> - “连接配置文件”是一组已保存的网络设置（例如 IP 地址、DNS 服务器、网关、Wi-Fi 密码等）。这些就是您正在编辑的文件。
>
> #### `reload`
>
> - **代表**：`reload`。
> - **角色**：这是您想要对`connection`对象执行的“操作”。
> - **功能**：此操作专门指示正在运行的 NetworkManager 守护程序丢弃其当前内存中的连接配置文件缓存，并从存储在硬盘上的配置文件（主要来自`/etc/NetworkManager/system-connections/`）中重新加载它们。





#### 3.3 ping 相关语法

`ping [一些特殊要求] [你要找谁]`

`ping -c 3 hadoop3`意思是：**“通过发送恰好 3 个测试数据包来测试与指定计算机的网络连接`hadoop3`，并向我显示结果。”**

> #### `ping`
>
> - **代表**：**P** acket **I** nter **net** **Groper**。
> - **角色**：这是程序的名称。它是一个用于测试网络连接的通用工具。
> - **工作原理**：它会通过网络向目标机器发送一种名为**ICMP 回显请求 (ICMP Echo Request)的特殊轻量级消息。如果目标机器收到该消息且运行正常，它会立即返回****ICMP 回显回复 (ICMP Echo Reply)**。该`ping`工具会测量回复是否返回以及往返时间。
>
> 
>
> #### `-c 3`（控制行为的选项）
>
> 这部分修改了`ping`命令的运行方式。
>
> - **`-c`**：这是一个代表**count**的“选项”或“标志” 。它告诉`ping`命令“我希望你发送特定*数量*的数据包”。
> - **`3`**：这是与选项关联的值`-c`。它指定数字应为**3**。
>
> **为什么这很重要？** 在 Linux 系统（例如虚拟机中的系统）上，如果您直接运行`ping hadoop3`而不使用此`-c`选项，它会一直 ping**下去**，直到您手动按下 停止它`Ctrl + C`。使用`-c 3`可以快速、干净地完成测试，并自动停止。
>
> 
>
> #### `hadoop3`（目标）
>
> - **角色**：这是测试的**目的地**。它是您要检查的计算机的主机名。
> - **第一步，隐藏的步骤**：在`ping`发送任何网络数据包之前，幕后会发生一个关键的步骤：**名称解析**。
>   1. 您的操作系统会看到该名称`hadoop3`。
>   2. 它遵循中的规则，该规则告诉它首先`/etc/nsswitch.conf`查看文件。`/etc/hosts`
>   3. `192.168.121.162 hadoop3`它在您的`/etc/hosts`文件中找到该行。
>   4. 它成功地将名称转换`hadoop3`为 IP 地址`192.168.121.162`。
>   5. 只有在转换成功后，它才会告诉`ping`程序开始向发送数据包`192.168.121.162`





#### 3.4 sed 相关语法

可以把 `sed` 想象成一个非常听话、速度极快的**“文本编辑机器人”**

不需要亲自打开一个文件（比如用`vi`），而是在命令行**给这个机器人下达一批指令**，它就会冲进文件里，一行一行地检查文本，并严格按照你的指令完成修改。

 `sed` 的基本语法 “公式” ： **`sed [特殊要求] '[指令清单]' [要去处理的文档]`**

> **[干“什么”活] (动作)** - 告诉机器人具体做什么。
>
> - **`s`** (substitute - **替换**): 这是 `sed` **最最最常用**的动作！
>   - **语法**: `s/旧东西/新东西/g`
>   - **通俗解释**: “给我**s**earch（寻找）‘旧东西’，然后把它换成‘新东西’”。最后的 `g` (global)表示把这一行所有匹配到的“旧东西”都换掉，而不只是第一个。
> - **`d`** (delete - **删除**)
>   - **通俗解释**: “把符合条件的**整一行**都给**d**elete（删除）掉。”
> - **`a`** (append - **追加**)
>   - **通俗解释**: “在符合条件的行**后面**，**a**ppend（追加）一行新内容。”
> - **`i`** (insert - **插入**)
>   - **通俗解释**: “在符合条件的行**前面**，**i**nsert（插入）一行新内容。”











###  4. 常用文本处理命令选项速查表

`sed` 和它最亲密的“兄弟”命令 `grep` 的一些最常用选项。`grep` 负责“查找”，`sed` 负责“编辑”，它们俩是处理文本的黄金搭档。

#### `sed` (文本编辑机器人)

| 选项     | 含义 (Mnemonic)      | 通俗解释 (机器人指令)                                        | 示例 (Example)                                         |
| -------- | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| **`-i`** | **i**n-place         | “**直接修改**源文件，别给我预览，我确定要这么干！”           | `sed -i 's/old/new/' file.txt`                         |
| **`-n`** | **n**o output        | “**安静模式**！默认别打印任何东西，除非我用`p`命令叫你打印。” | `sed -n '/error/p' log.txt` (只打印包含error的行)      |
| **`-e`** | **e**xpression       | “听好了，我要给你**多条指令**，这条指令完了还有下一条。”     | `sed -i -e 's/cat/dog/' -e 's/apple/orange/' file.txt` |
| **`-r`** | **r**egex (extended) | “我要用**更高级、更简洁的正则语法**，你帮我识别一下。”       | `sed -r 's/(dog                                        |

------



#### `grep` (文本搜索侦探)



| 选项               | 含义 (Mnemonic)  | 通俗解释 (侦探指令)                                          | 示例 (Example)                                            |
| ------------------ | ---------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| **`-i`**           | **i**gnore case  | “**忽略大小写**！不管是 `Error` 还是 `error`，都给我找出来。” | `grep -i "error" log.txt`                                 |
| **`-v`**           | in**v**ert match | “**反向查找**！把不包含这个词的行给我看，其他的都不要。”     | `grep -v "DEBUG" log.txt` (过滤掉所有调试信息)            |
| **`-r`**           | **r**ecursive    | “**深入挖掘**！不光查这个文件，把这个文件夹及里面所有文件夹都给我查一遍。” | `grep -r "password" /etc/`                                |
| **`-c`**           | **c**ount        | “别给我看具体内容，就告诉我找到了**多少行**，给我个总数就行。” | `grep -c "SUCCESS" access.log`                            |
| **`-l`**           | **l**ist files   | “别告诉我具体在哪一行，就告诉我**哪些文件**里包含这个词就行了。” | `grep -l "main" *.java`                                   |
| **`-n`**           | line **n**umber  | “找到之后，在前面把**行号**也给我标出来，方便我回去找。”     | `grep -n "Exception" app.log`                             |
| **`--color=auto`** | color            | “找到的关键词，用**高亮颜色**给我标出来，显眼一点！”         | `grep --color=auto "root" /etc/passwd` (很多系统默认开启) |

